find :: (Int -> Bool) -> [Int] -> (Int, [Int])
find cond [] = (-1, []) -- Это некорректно, но мы же для простоты считаем, что find всегда точно найдёт элемент, удовлетворяющий условию. Пришлось добавить эту строчку из-за ошибки "Non-exhaustive patterns in function find".
find cond (x:xs) = if cond x then (x, xs) else find cond xs


-- Идея: частично применить функцию g.
(>>>=) :: ([a] -> (a, [a])) -> (a -> ([a] -> (a, [a]))) -> ([a] -> (a, [a]))
f >>>= g = \ls ->
  let
    (res, ls1) = f ls
  in (g res) ls1

-- Пример вызова этого всего.
test1 = ((find (>3)) >>>= (\x -> (find (>x)))) [1, 2, 3, 4, 5, 1, 1] -- (5,[1,1])
test2 = ((find (>1)) >>>= (\x -> (find (>x)))) [1, 2, 3, 4, 5, 1, 1] -- (3,[4,5,1,1])
